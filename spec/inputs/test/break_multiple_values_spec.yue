describe "break with multiple values", ->
	it "should break with multiple values from numeric for loop", ->
		x, y = for i = 1, 10
			if i > 5
				break i, i * 2
		assert.same x, 6
		assert.same y, 12

	it "should break with multiple values from ipairs iterator", ->
		x, y = for _, v in ipairs [1, 2, 3]
			if v > 2
				break v, v * 2
		assert.same x, 3
		assert.same y, 6

	it "should break with multiple values from destructuring iterator", ->
		x, y = for [a, b] in *{[10, 20], [30, 40], [40, 50]}
			if b > 20
				break a, b * 2
		assert.same x, 30
		assert.same y, 80

	it "should break with multiple values from do block", ->
		x, y = do
			break 1, 2
		assert.same x, 1
		assert.same y, 2

	it "should break with multiple values from with statement", ->
		x = with abc: 99, flag: true
			break .abc if .flag
			break 0
		assert.same x, 99

	it "should work with continue in comprehension", ->
		input = {1,2,3,4,5,6}
		output = for x in *input
			continue if x % 2 == 1
			x
		assert.same output, {2, 4, 6}

	it "should break in comprehension with index", ->
		f1 = ->
			tb = [true, true, false]
			index = for i = 1, #tb
				break i if tb[i]
			index
		assert.same f1!, 1

	it "should work with continue in indexed comprehension", ->
		input = {1,2,3,4,5,6}
		output = for i = 1, #input
			x = input[i]
			continue if x % 2 == 1
			x
		assert.same output, {2, 4, 6}

	it "should break with multiple values in simple for loop", ->
		a, b = for i = 1, 5
			if i == 2
				break i, i * 10
		assert.same a, 2
		assert.same b, 20

	it "should break with expression values", ->
		sum, product = for i = 1, 3
			if i == 2
				break i + i, i * i
		assert.same sum, 4
		assert.same product, 4

	it "should break with table iteration values", ->
		key, value = for k, v in pairs {a: 1, b: 2, c: 3}
			if k == "b"
				break k, v * 10
		assert.same key, "b"
		assert.same value, 20

	it "should break in for loop with multiple values", ->
		count, total = for i = 1, 10
			if i == 5
				break i, i * 10
		assert.same count, 5
		assert.same total, 50

	it "should break in repeat loop with multiple values", ->
		i = 1
		i, doubled = repeat
			if i > 3
				break i, i * 100
			i += 1
		until false
		assert.same i, 4
		assert.same doubled, 400

	it "should work with with? and break", ->
		dummy = (x) -> x
		result = with? value: 1
			dummy with? nil
				break .value
			break .value
		assert.same result, 1

	it "should break with multiple values in do block", ->
		x, y = do
			break 10, 30
		assert.same x, 10
		assert.same y, 30

	it "should break with string and number values", ->
		name, age = for k, v in pairs {name: "Alice", age: 30, city: "NYC"}
			if k == "name"
				break v, 25
		assert.same name, "Alice"
		assert.same age, 25

	it "should break with nil values", ->
		a, b, c = for i = 1, 5
			if i == 3
				break i, nil, "test"
		assert.same a, 3
		assert.same b, nil
		assert.same c, "test"

	it "should break with boolean values", ->
		found, value = for i = 1, 5
			if i == 3
				break true, "found"
		assert.is_true found
		assert.same value, "found"

	it "should break with function call values", ->
		fn = -> 42
		val, dbl = for i = 1, 3
			if i == 2
				break fn!, fn! * 2
		assert.same val, 42
		assert.same dbl, 84

	it "should break with multiple values for destructuring", ->
		x, y = for [a, b] in *{[1, 2], [3, 4], [5, 6]}
			if a > 2
				break b, a
		assert.same x, 4
		assert.same y, 3

	it "should break in switch-like logic", ->
		status, message = for i = 1, 3
			do
				if i == 1
					break "ok", "one"
				if i == 2
					break "ok", "two"
		assert.same status, "ok"
		assert.same message, "one"

	it "should handle multiple break conditions", ->
		idx, val = for i = 1, 10
			if i == 3
				break i, "first"
			if i == 7
				break i, "second"
		assert.same idx, 3
		assert.same val, "first"

	it "should break with computed values", ->
		sum, count = for i = 1, 5
			if i == 4
				break 10 + i, i
		assert.same sum, 14
		assert.same count, 4

	it "should break with table literal", ->
		name, data = for i = 1, 3
			if i == 2
				break "item", {value: i, index: i}
		assert.same name, "item"
		assert.same data.value, 2
		assert.same data.index, 2

	it "should break with string concatenation", ->
		prefix, suffix = for i = 1, 3
			if i == 2
				break "pre", "fix"
		assert.same prefix .. suffix, "prefix"

	it "should break with continue in loop", ->
		x, y = for i = 1, 5
			if i == 3
				break i, i * 2
		assert.same x, 3
		assert.same y, 6

	it "should break with ternary-like expression", ->
		result, is_valid = for i = 1, 5
			if i == 3
				break i, i > 2
		assert.same result, 3
		assert.is_true is_valid

	it "should break with arithmetic operations", ->
		sum, diff = for i = 1, 5
			if i == 3
				break i + 10, 10 - i
		assert.same sum, 13
		assert.same diff, 7

	it "should break with table access", ->
		data = {a: 1, b: 2}
		first, second = for i = 1, 3
			if i == 2
				break data.a, data.b
		assert.same first, 1
		assert.same second, 2

	it "should break with literal values", ->
		a, b = for i = 1, 3
			if i == 2
				break "x", "y"
		assert.same a, "x"
		assert.same b, "y"

	it "should break with conditional expression", ->
		status, msg = for i = 1, 5
			if i == 3
				break "ok", "done"
		assert.same status, "ok"
		assert.same msg, "done"

	it "should handle multiple breaks in sequence", ->
		val1, val2 = for i = 1, 10
			if i == 3
				break i, i * 2
			if i == 5
				break i, i * 3
			if i == 7
				break i, i * 4
		assert.same val1, 3
		assert.same val2, 6

	it "should handle multiple breaks in switch", ->
		val1, val2 = for i = 1, 10 do switch i
			when 3 then break i, i * 2
			when 5 then break i, i * 3
			when 7 then break i, i * 4
		assert.same val1, 3
		assert.same val2, 6

	it "should break with nil and default", ->
		a, b = for i = 1, 5
			if i == 2
				break i, nil
		assert.same a, 2
		assert.is_nil b

	it "should break with false and value", ->
		found, data = for i = 1, 5
			if i == 3
				break false, "item"
		assert.is_false found
		assert.same data, "item"

	it "should break with three values", ->
		a, b, c = for i = 1, 5
			if i == 3
				break i, i * 2, i * 3
		assert.same a, 3
		assert.same b, 6
		assert.same c, 9

	it "should break in while loop", ->
		i = 1
		count, total = while i < 10
			if i == 5
				break i, i * 10
			i += 1
		assert.same count, 5
		assert.same total, 50

	it "should handle early break in loop", ->
		a, b = for i = 1, 100
			if i == 1
				break "first", "second"
		assert.same a, "first"
		assert.same b, "second"

	it "should break with multiple function calls", ->
		add = (a, b) -> a + b
		mul = (a, b) -> a * b
		sum, product = for i = 1, 5
			if i == 3
				break add(i, i), mul(i, i)
		assert.same sum, 6
		assert.same product, 9

	it "should work with chained comparisons", ->
		x, y = for i = 1, 10
			if 3 < i and i < 7
				break i, i * i
		assert.same x, 4
		assert.same y, 16

	it "should work with logical expressions", ->
		flag, value = for i = 1, 5
			if i > 2 and i < 4
				break true, i
		assert.is_true flag
		assert.same value, 3

	it "should work with table unpacking in break", ->
		tbl = {10, 20}
		a, b = for i = 1, 5
			if i == 3
				break tbl[1], tbl[2]
		assert.same a, 10
		assert.same b, 20

	it "should work with nested conditions", ->
		result, flag = for i = 1, 10
			if i > 2
				if i < 5
					if i == 3
						break i, true
		assert.same result, 3
		assert.is_true flag

	it "should work with class methods", ->
		class MyClass
			find_pair: =>
				result = [
					for i = 1, 10
						if i == 5
							break i, i * 10
				]
				result
		obj = MyClass!
		result = obj\find_pair!
		assert.same result[1], 5
		assert.same result[2], 50

	it "should work with string interpolation", ->
		a, b = for i = 1, 5
			if i == 3
				break "item-#{i}", "value-#{i * 10}"
		assert.same a, "item-3"
		assert.same b, "value-30"

	it "should work with try-catch", ->
		try
			result, error_msg = for i = 1, 5
				if i == 3
					break i, "found"
			assert.same result, 3
			assert.same error_msg, "found"
		catch e
			error "Should not reach here"

	it "should work with const attribute", ->
		const MAX = 10
		first, second = for i = 1, MAX
			if i == 5
				break i, i * 2
		assert.same first, 5
		assert.same second, 10

	it "should work with backcall style processing", ->
		a, b = for i = 1, 5
			if i == 3
				break i, i * 2
		assert.same a, 3
		assert.same b, 6

	it "should work with varargs", ->
		process = (...) ->
			items = {...}
			a, b = for i = 1, #items
				if items[i] == 3
					break items[i], items[i] * 2
			a, b
		result1, result2 = process 1, 2, 3, 4, 5
		assert.same result1, 3
		assert.same result2, 6

	it "should work with table slicing", ->
		matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9]]
		sub, val = for i = 1, #matrix
			if matrix[i][1] == 4
				break matrix[i][1], matrix[i][2]
		assert.same sub, 4
		assert.same val, 5

	it "should work with chaining comparison", ->
		result, flag = for i = 1, 10
			if 1 < i <= 5 < 10
				break i, i * i
		assert.same result, 2
		assert.same flag, 4

	it "should work with implicit return", ->
		fn = ->
			result = [
				for i = 1, 5
					if i == 3
						break i, i * 10
			]
			result
		result = fn!
		assert.same result[1], 3
		assert.same result[2], 30

	it "should work with nil coalescing", ->
		data = nil
		first, second = for i = 1, 5
			if i == 3
				break i, i * 2
		assert.same first, 3
		assert.same second, 6

	it "should work with table literal shorthand", ->
		a, b = for i = 1, 5
			if i == 2
				break "first", "second"
		assert.same a, "first"
		assert.same b, "second"

	it "should work with method calls", ->
		obj = {
			start: 10
			end_val: 20
			find: =>
				result = [
					for i = 1, 10
						if i == 4
							break @start + i, @end_val + i
				]
				result
		}
		result = obj\find!
		assert.same result[1], 14
		assert.same result[2], 24

	it "should work with do-end assignment", ->
		a, b = do
			x, y = for i = 1, 5
				if i == 2
					break i, i * 5
			x, y
		assert.same a, 2
		assert.same b, 10

	it "should work with unary operators", ->
		result, negated = for i = 1, 5
			if i == 3
				break i, -i
		assert.same result, 3
		assert.same negated, -3

	it "should work with bitwise operators", ->
		a, b = for i = 1, 10
			if i == 4
				break i ~ 1, i | 8
		assert.same a, 5
		assert.same b, 12

	it "should work with modulo operation", ->
		quotient, remainder = for i = 1, 10
			if i == 7
				break i // 3, i % 3
		assert.same quotient, 2
		assert.same remainder, 1

	it "should work with exponentiation", ->
		base, squared = for i = 1, 5
			if i == 3
				break i, i ^ 2
		assert.same base, 3
		assert.same squared, 9

	it "should work with length operator", ->
		str, len = for i = 1, 5
			if i == 3
				break "hello", #"hello"
		assert.same str, "hello"
		assert.same len, 5

	it "should work with table concatenation", ->
		part1, part2 = for i = 1, 5
			if i == 2
				break {1, 2}, {3, 4}
		assert.same part1, {1, 2}
		assert.same part2, {3, 4}

	it "should work with nested do blocks", ->
		result = do
			temp = {
				for i = 1, 5
					do
						if i == 3
							break i, i * 2
			}
			temp[1] + temp[2]
		assert.same result, 9

	it "should work with table.insert", ->
		results = {}
		item, index = for i = 1, 5
			if i == 3
				break i, i * 2
			table.insert results, i
		assert.same results, {1, 2}

	it "should break with multiple values in nested for loops", ->
		x, y = for i = 1, 5
			a, b = for j = 1, 5
				if i == 2 and j == 3
					break i, j
			break a, b if a
		assert.same x, 2
		assert.same y, 3

	it "should break with multiple values in for nested while", ->
		x, y = for i = 1, 10
			j = 1
			a, b = while j < 10
				if i == 3 and j == 5
					break i, j
				j += 1
			break a, b if a and b
		assert.same x, 3
		assert.same y, 5

	it "should break with multiple values in while nested for", ->
		i = 1
		x, y = while i < 10
			a, b = for j = 1, 10
				if i == 3 and j == 4
					break i, j
			i += 1
			break a, b if a and b
		assert.same x, 3
		assert.same y, 4

	it "should break with multiple values in for nested repeat", ->
		x, y = for i = 1, 5
			j = 1
			a, b = repeat
				if i == 2 and j == 3
					break i, j
				j += 1
			until j > 10
			break a, b if a and b
		assert.same x, 2
		assert.same y, 3

	it "should break with multiple values in repeat nested for", ->
		i = 1
		x, y = repeat
			a, b = for j = 1, 5
				if i == 3 and j == 2
					break i, j
			i += 1
			break a, b if a and b
		until i > 10
		assert.same x, 3
		assert.same y, 2

	it "should break with multiple values in do nested for", ->
		x, y = do
			a1, b1 = for i = 1, 5
				a, b = for j = 1, 5
					if i == 2 and j == 3
						break i, j
				break a, b if a and b
			break a1, b1
		assert.same x, 2
		assert.same y, 3

	it "should break with multiple values in for nested do", ->
		x, y = for i = 1, 5
			do
				if i == 3
					break i, i * 2
		assert.same x, 3
		assert.same y, 6

	it "should break with multiple values in for nested with", ->
		x, y = for i = 1, 5
			with value: i, index: i * 2
				if .value == 3
					break .value, .index
		assert.same x, 3
		assert.same y, 6

	it "should break with a value in with nested for", ->
		x = with {limit: 5}
			break for i = 1, .limit
				if i == 3
					break i
		assert.same x, 3

	it "should break with multiple values in three-level nested loops", ->
		x, y, z = for i = 1, 3
			a1, a2, a3 = for j = 1, 3
				b1, b2, b3 = for k = 1, 3
					if i == 2 and j == 2 and k == 2
						break i, j, k
				break b1, b2, b3 if b1
			break a1, a2, a3 if a1
		assert.same x, 2
		assert.same y, 2
		assert.same z, 2

	it "should break with multiple values in while nested repeat", ->
		i = 1
		x, y = while i < 10
			j = 1
			a, b = repeat
				if i == 3 and j == 4
					break i, j
				j += 1
			until j > 10
			i += 1
			break a, b if a
		assert.same x, 3
		assert.same y, 4

	it "should break with multiple values in repeat nested while", ->
		i = 1
		x, y = repeat
			j = 1
			a, b = while j < 10
				if i == 4 and j == 3
					break i, j
				j += 1
			i += 1
			break a, b if a
		until i > 10
		assert.same x, 4
		assert.same y, 3

	it "should break with multiple values in do nested while", ->
		i = 1
		x, y = do
			a, b = while i < 10
				if i == 4
					break i, i * 3
				i += 1
			break a, b
		assert.same x, 4
		assert.same y, 12

	it "should break with multiple values in while nested do", ->
		i = 1
		x, y = while i < 10
			a, b = do
				if i == 5
					break i, i * 4
			i += 1
			break a, b if a
		assert.same x, 5
		assert.same y, 20

	it "should break with multiple values in do nested repeat", ->
		i = 1
		x, y = do
			a, b = repeat
				if i == 3
					break i, i * 5
				i += 1
			until i > 10
			break a, b
		assert.same x, 3
		assert.same y, 15

	it "should break with multiple values in repeat nested do", ->
		i = 1
		x, y = repeat
			a, b = do
				if i == 2
					break i, i * 6
			i += 1
			break a, b if a
		until i > 10
		assert.same x, 2
		assert.same y, 12

	it "should break with multiple values in with nested do", ->
		x, y = do
			with value: 10, factor: 3
				a, b = do
					if .value > 5
						break .value, .factor
				break a, b
		assert.same x, 10
		assert.same y, 3

	it "should break with multiple values in do nested with", ->
		x, y = do
			with num: 42, text: "test"
				break .num, .text
		assert.same x, 42
		assert.same y, "test"

	it "should break with multiple values in for nested for with different types", ->
		name, age, active = for i = 1, 5
			a, b, c = for j = 1, 5
				if i == 2 and j == 3
					break "user-#{i}", j * 10, true
			break a, b, c if a
		assert.same name, "user-2"
		assert.same age, 30
		assert.is_true active

	it "should break with multiple values in with nested for with method calls", ->
		obj =
			data: [10, 20, 30, 40]
			find: =>
				x, y = for i = 1, #@data
					if @data[i] == 30
						break @data[i], i
				x, y
		value, index = obj\find!
		assert.same value, 30
		assert.same index, 3

	it "should break with multiple values in nested loops with early termination", ->
		found, idx = for i = 1, 10
			if i == 1
				break i, true
			a, b = for j = 1, 10
				break i, false if j == 5
			break a, b if a
		assert.same found, 1
		assert.is_true idx

	it "should break with multiple values in nested loops with computed expressions", ->
		sum, product = for i = 1, 5
			a, b = for j = 1, 5
				if i * j == 12
					break i + j, i * j
			break a, b if a
		assert.same sum, 7
		assert.same product, 12

	it "should mix break and break with values in same for expression", ->
		x, y = for i = 1, 5
			if i == 3
				break i, i * 10
			if i == 4
				break
		assert.same x, 3
		assert.same y, 30

	it "should return nils when plain break happens before value break", ->
		x, y = for i = 1, 5
			if i == 2
				break
			if i == 4
				break i, i * 10
		assert.is_nil x
		assert.is_nil y

	it "should mix plain break and value break across nested loops", ->
		matrix = {
			{1, -1, 9}
			{4, 5, 9}
		}
		row, col = for r = 1, #matrix
			a, b = for c = 1, #matrix[r]
				cell = matrix[r][c]
				break if cell < 0
				break r, c if cell == 9
			break a, b if a
		assert.same row, 2
		assert.same col, 3

	it "should mix break and break with values in while expression", ->
		i = 0
		x, y = while i < 5
			i += 1
			if i == 2
				break
			if i == 4
				break i, i * 2
		assert.is_nil x
		assert.is_nil y

	it "should mix break and break with values in do with with block", ->
		x, y = do
			with value: 8, stop: false
				break if .stop
				break .value, .value * 2
		assert.same x, 8
		assert.same y, 16

	it "should fall back to plain break in do with with block", ->
		x, y = do
			with value: 8, stop: true
				break if .stop
				break .value, .value * 2
			break
		assert.is_nil x
		assert.is_nil y

	it "should mix continue and break with values in for expression", ->
		x, y = for i = 1, 8
			continue if i % 3 ~= 0
			break i, i + 100 if i == 6
		assert.same x, 6
		assert.same y, 106

	it "should mix continue and break with values across nested for expressions", ->
		row, col = for r = 1, 3
			a, b = for c = 1, 4
				continue if c < 3
				break r, c if r == 2 and c == 3
			continue if not a
			break a, b
		assert.same row, 2
		assert.same col, 3

	it "should mix break continue and value break with plain break winning", ->
		x, y = for i = 1, 7
			continue if i < 3
			if i == 4
				break
			if i == 6
				break i, i * 10
		assert.is_nil x
		assert.is_nil y

	it "should mix break continue and value break with value break winning", ->
		x, y = for i = 1, 9
			continue if i % 2 == 0
			if i == 5
				break i, i * 3
			if i == 9
				break
		assert.same x, 5
		assert.same y, 15

	it "should allow nesting do and for", ->
		x, y = do
			min, max = 1, 10
			if max > min
				break for j = min, max
					break j, j * 10 if j > 5
			break 0, 0
		assert.same x, 6
		assert.same y, 60

	it "should allow nesting do and with", ->
		x = with a: 123, b: true
			do
				if .b
					break with a: .a, b: .b, c: "ok"
						if .b and .c == "ok"
							break .a
		assert.same x, 123

describe "parameter destructuring", ->
	it "should destructure simple object", ->
		f = (:a, :b, :c) ->
			{a, b, c}

		result = f a: 1, b: "2", c: {}
		assert.same result, {1, "2", {}}

	it "should work with default values", ->
		f = ({a: a1 = 123, :b = 'abc'}, c = {}) ->
			{a1, b, c}

		result1 = f {a: 0}, "test"
		assert.same result1, {0, 'abc', 'test'}

		result2 = f {}
		assert.same result2, {123, 'abc', {}}

	it "should destructure with mixed syntax", ->
		f = (:a, b: b1, :c) ->
			{a, b1, c}

		result = f a: 1, b: 2, c: 3
		assert.same result, {1, 2, 3}

	it "should work with nested destructuring", ->
		f = ({nested: {:x, :y}}) ->
			{x, y}

		result = f nested: {x: 10, y: 20}
		assert.same result, {10, 20}

	it "should handle array parameters", ->
		f = ([a, b, c]) ->
			{a, b, c}

		result = f [1, 2, 3]
		assert.same result, {1, 2, 3}

	it "should support mixed array and object", ->
		f = ([first,], {key: :value}) ->
			{first, value}

		result = f [1,], {key: value: "test"}
		assert.same result, {1, "test"}

	it "should work with fat arrow", ->
		obj =
			value: 100
			f: ({:x, :y}) =>
				@value + x + y

		result = obj\f {x: 10, y: 20}
		assert.same result, 130

	it "should handle missing keys", ->
		f = ({:a, :b = "default", :c = "missing"}) ->
			{a, b, c}

		result = f a: 1
		assert.same result, {1, 'default', 'missing'}

	it "should work with complex defaults", ->
		f = ({a: a1 = 100, b: b1 = a1 + 1000}) ->
			a1 + b1

		result = f {}
		assert.same result, 1200

	it "should support deep nesting", ->
		f = ({data: {nested: {:value}}}) ->
			value

		result = f data: {nested: {value: 42}}
		assert.same result, 42

	it "should work with multiple parameters", ->
		f = (:x, :y, :z, extra = "default") ->
			{x, y, z, extra}

		result = f x: 1, y: 2, z: 3
		assert.same result, {1, 2, 3, 'default'}

	it "should handle array destructuring in parameters", ->
		f = ([first, ...rest]) ->
			{first, rest}

		result = f [1, 2, 3, 4]
		assert.same result, {1, {2, 3, 4}}

	it "should support spreading", ->
		f = ({...rest, :last}) ->
			{rest, last}
	
		result = f {1, 2, 3, last: "final"}
		assert.same result, {{1, 2, 3}, 'final'}

	it "should work with table comprehensions", ->
		f = ({:items}) ->
			[item * 2 for item in *items]

		result = f items: {1, 2, 3}
		assert.same result, {2, 4, 6}

	it "should handle nil arguments", ->
		f = ({:a = "nil_a", :b = "nil_b"}) ->
			{a, b}
	
		result = f {}
		assert.same result, {"nil_a", "nil_b"}

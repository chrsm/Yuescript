describe "config", ->
	-- Note: These tests verify that various compiler configs don't cause errors
	-- Actual compiler config testing would require the compiler itself

	it "should handle implicit return", ->
		-- implicitReturnRoot is the default
		fn = ->
			42
		assert.same fn!, 42

	it "should handle return in last position", ->
		fn = ->
			if true
				100
			else
				200
		assert.same fn!, 100

	it "should work with various code patterns", ->
		-- Test that code compiles without explicit config
		x = 1 + 2
		y = if x > 0 then "positive" else "negative"
		assert.same y, "positive"

	it "should handle class definitions", ->
		class TestClass
			value: 100
			get_value: => @value
		instance = TestClass!
		assert.same instance\get_value!, 100

	it "should handle macro definitions", ->
		macro test_macro = (x) -> "#{x} + 1"
		result = $test_macro 5
		assert.same result, 6

	it "should handle import statements", ->
		import format from "string"
		assert.is_true type(format) == "function"

	it "should handle string interpolation", ->
		name = "world"
		result = "hello #{name}"
		assert.same result, "hello world"

	it "should handle comprehensions", ->
		result = [x * 2 for x = 1, 5]
		assert.same result, {2, 4, 6, 8, 10}

	it "should handle switch expressions", ->
		result = switch 2
			when 1 then "one"
			when 2 then "two"
			else "other"
		assert.same result, "two"

	it "should handle with statements", ->
		obj = {x: 10, y: 20}
		result = with obj
			.x + .y
		assert.same result, 30

	it "should handle existential operators", ->
		obj = {value: 100}
		result = obj?.value
		assert.same result, 100

	it "should handle pipe operator", ->
		result = {1, 2, 3} |> table.concat
		assert.same result, "123"

	it "should handle loops", ->
		sum = 0
		for i = 1, 5
			sum += i
		assert.same sum, 15

	it "should handle while loops", ->
		count = 0
		while count < 3
			count += 1
		assert.same count, 3

	it "should handle table literals", ->
		t = {
			key1: "value1"
			key2: "value2"
		}
		assert.same t.key1, "value1"

	it "should handle function definitions", ->
		fn = (a, b) -> a + b
		assert.same fn(5, 3), 8

	it "should handle nested functions", ->
		outer = ->
			inner = (x) -> x * 2
			inner 10
		assert.same outer!, 20

	it "should handle destructure", ->
		t = {x: 1, y: 2, z: 3}
		{:x, :y, :z} = t
		assert.same x, 1
		assert.same y, 2
		assert.same z, 3

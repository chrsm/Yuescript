describe "do statement", ->
	it "should create new scope", ->
		x = 10
		do
			local x = 20
			assert.same x, 20
		assert.same x, 10

	it "should return value from do block", ->
		result = do
			x = 5
			x * 2
		assert.same result, 10

	it "should work with multiple statements", ->
		result = do
			a = 1
			b = 2
			c = 3
			a + b + c
		assert.same result, 6

	it "should handle nested do blocks", ->
		result = do
			x = 10
			y = do
				z = 5
				z * 2
			x + y
		assert.same result, 20

	it "should support conditional in do block", ->
		result = do
			value = 5
			if value > 3
				value * 2
			else
				value
		assert.same result, 10

	it "should work with loops in do block", ->
		result = do
			sum = 0
			for i = 1, 5
				sum += i
			sum
		assert.same result, 15

	it "should handle table operations", ->
		result = do
			tb = {1, 2, 3}
			table.insert tb, 4
			#tb
		assert.same result, 4

	it "should work with function definition", ->
		result = do
			fn = (x) -> x * 2
			fn 5
		assert.same result, 10

	it "should support variable shadowing", ->
		x = "outer"
		result = do
			x = "inner"
			x
		assert.same result, "inner"
		assert.same x, "outer"

	it "should work with method calls", ->
		obj =
			value: 10
			double: => @value * 2

		result = do
			with obj
				\double!
		assert.same result, 20

	it "should handle comprehensions in do block", ->
		result = do
			items = [1, 2, 3, 4, 5]
			[item * 2 for item in *items]
		assert.same result, {2, 4, 6, 8, 10}

	it "should work with try-catch", ->
		result = do
			success = try
				error "test error"
				false
			catch err
				true
		assert.is_true success

	it "should support return statement", ->
		fn = ->
			do
				x = 10
				return x * 2
			"never reached"

		result = fn!
		assert.same result, 20

	it "should work with assignment", ->
		result = do
			a, b, c = 1, 2, 3
			a + b + c
		assert.same result, 6

	it "should handle destructuring", ->
		result = do
			tb = {x: 10, y: 20}
			{:x, :y} = tb
			x + y
		assert.same result, 30

	it "should work with string interpolation", ->
		name = "world"
		result = do
			greeting = "hello"
			"#{greeting} #{name}"
		assert.same result, "hello world"

	it "should support implicit return", ->
		result = do
			value = 42
		assert.same result, 42

	it "should handle empty do block", ->
		result = do
		assert.same result, nil

	it "should work with backcalls", ->
		result = do
			items = [1, 2, 3]
			(x) <- map _, items
			x * 2
		assert.same result, {2, 4, 6}

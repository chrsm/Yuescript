describe "named varargs", ->
	it "should store varargs in named table", ->
		f = (...t) ->
			assert.same t.n, 3
			assert.same t[1], 1
			assert.same t[2], 2
			assert.same t[3], 3

		f 1, 2, 3

	it "should handle string arguments", ->
		f = (...args) ->
			assert.same args.n, 3
			assert.same args[1], "a"
			assert.same args[2], "b"
			assert.same args[3], "c"

		f "a", "b", "c"

	it "should handle empty varargs", ->
		f = (...t) ->
			assert.same t.n, 0
			assert.same #t, 0

		f!

	it "should preserve nil values", ->
		f = (...args) ->
			assert.same args.n, 5
			assert.same args[1], 1
			assert.same args[2], nil
			assert.same args[3], 3
			assert.same args[4], nil
			assert.same args[5], 5

		f 1, nil, 3, nil, 5

	it "should work with loop", ->
		f = (...t) ->
			sum = 0
			for i = 1, t.n
				sum += t[i] if type(t[i]) == "number"
			sum

		result = f 1, 2, 3, 4, 5
		assert.same result, 15

	it "should handle mixed types", ->
		f = (...args) ->
			types = [type(args[i]) for i = 1, args.n]
			types

		result = f "string", 123, true, nil, {}
		assert.same result, {"string", "number", "boolean", "nil", "table"}

	it "should work with table access", ->
		f = (...t) ->
			first = t[1]
			last = t[t.n]
			{first, last}

		result = f 1, 2, 3, 4, 5
		assert.same result, {1, 5}

	it "should support select with named args", ->
		f = (...args) ->
			second = select 2, table.unpack args
			second

		result = f "a", "b", "c"
		assert.same result, "b"

	it "should work with pcall", ->
		f = (...t) ->
			success = true
			for i = 1, t.n
				if t[i] == nil
					success = false
			success

		result = f 1, nil, 3
		assert.is_false result

	it "should handle function results", ->
		g = -> 1, 2, 3
		f = (...t) ->
			t.n

		result = f g!
		assert.same result, 3

	it "should work with unpacking", ->
		f = (...args) ->
			{table.unpack args}

		result = f "a", "b", "c"
		assert.same result, {"a", "b", "c"}

	it "should support passing named varargs to another function", ->
		outer = (...t) ->
			inner (table.unpack t)

		inner = (a, b, c) ->
			{a, b, c}

		result = outer 1, 2, 3
		assert.same result, {1, 2, 3}

	it "should work with default parameter", ->
		f = (x = 10, ...t) ->
			x + t[1] or 0

		result = f 5, 15
		assert.same result, 20

	it "should handle single argument", ->
		f = (...t) ->
			{t.n, t[1]}

		result = f 42
		assert.same result, {1, 42}
